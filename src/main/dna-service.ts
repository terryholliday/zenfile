import { promises as fs } from 'fs'
import path from 'path'
import { aiService } from './ai-service'
import { logger } from './logger'

class DnaService {
  private static instance: DnaService

  private constructor() {}

  static getInstance(): DnaService {
    if (!DnaService.instance) {
      DnaService.instance = new DnaService()
    }
    return DnaService.instance
  }

  async generateProjectDna(folderPath: string): Promise<string> {
    try {
      logger.info(`Generating DNA for ${folderPath}`)

      // 1. Scan folder
      const files = await fs.readdir(folderPath)
      const candidates = files.filter(
        (f) => !f.startsWith('.') && !f.startsWith('node_modules') && f !== 'README.md'
      )

      const SAFE_EXTS = new Set([
        '.txt',
        '.md',
        '.ts',
        '.tsx',
        '.js',
        '.jsx',
        '.json',
        '.py',
        '.java',
        '.c',
        '.cpp',
        '.h',
        '.css',
        '.html',
        '.css',
        '.scss',
        '.yaml',
        '.yml'
      ])
      const MAX_TOTAL_CHARS = 15000 // Hard cap to prevent OOM / Token overload

      // 2. Parallel Read with Cap
      let totalChars = 0
      const snippets: string[] = []

      // Read files in parallel batches to speed up IO without opening 1000s of handles
      const BATCH_SIZE = 10

      for (let i = 0; i < candidates.length; i += BATCH_SIZE) {
        if (totalChars >= MAX_TOTAL_CHARS) break

        const batch = candidates.slice(i, i + BATCH_SIZE)

        await Promise.all(
          batch.map(async (file) => {
            if (totalChars >= MAX_TOTAL_CHARS) return

            const filePath = path.join(folderPath, file)
            try {
              const stats = await fs.stat(filePath)
              if (stats.isDirectory() || stats.size > 100 * 1024) return // Skip dirs and large files (>100kb)

              const ext = path.extname(file).toLowerCase()
              if (SAFE_EXTS.has(ext)) {
                const content = await fs.readFile(filePath, 'utf-8')
                const snippet = `\n--- FILE: ${file} ---\n${content.substring(0, 500)}\n`

                if (totalChars + snippet.length < MAX_TOTAL_CHARS) {
                  snippets.push(snippet)
                  totalChars += snippet.length
                }
              }
            } catch (e) {
              // Ignore read errors
            }
          })
        )
      }

      const context = snippets.join('')

      if (context.length < 50) return 'Insufficient content to generate DNA.'

      // 3. Generate Summary
      const prompt = `Summarize this project based on these file snippets. Create a brief README intro:\n${context}`

      // Ensure aiService.generateSummary exists (restored above)
      const summary = await aiService.generateSummary(prompt)

      // 4. Write README
      const readmePath = path.join(folderPath, 'README.md')
      const readmeContent = `# Project DNA\n\n> Auto-generated by FileZen\n\n## Summary\n${summary}\n\n## Files Analyzed\n- ${candidates.slice(0, 10).join('\n- ')}${candidates.length > 10 ? '\n- ...' : ''}`

      await fs.writeFile(readmePath, readmeContent)

      return readmeContent
    } catch (error: any) {
      logger.error('Failed to generate Project DNA', { error: error.message })
      throw error
    }
  }
}

export const dnaService = DnaService.getInstance()
